/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "MCoordinateSystemMapper.h"

namespace MMIStandard {


MCoordinateSystemMapper_TransformToMMI_L_args::~MCoordinateSystemMapper_TransformToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size420;
            ::apache::thrift::protocol::TType _etype423;
            xfer += iprot->readListBegin(_etype423, _size420);
            this->coordinateSystem.resize(_size420);
            uint32_t _i424;
            for (_i424 = 0; _i424 < _size420; ++_i424)
            {
              int32_t ecast425;
              xfer += iprot->readI32(ecast425);
              this->coordinateSystem[_i424] = (MDirection::type)ecast425;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter426;
    for (_iter426 = this->coordinateSystem.begin(); _iter426 != this->coordinateSystem.end(); ++_iter426)
    {
      xfer += oprot->writeI32((int32_t)(*_iter426));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_pargs::~MCoordinateSystemMapper_TransformToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter427;
    for (_iter427 = (*(this->coordinateSystem)).begin(); _iter427 != (*(this->coordinateSystem)).end(); ++_iter427)
    {
      xfer += oprot->writeI32((int32_t)(*_iter427));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_result::~MCoordinateSystemMapper_TransformToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_presult::~MCoordinateSystemMapper_TransformToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_args::~MCoordinateSystemMapper_TransformToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast428;
          xfer += iprot->readI32(ecast428);
          this->firstAxis = (MDirection::type)ecast428;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast429;
          xfer += iprot->readI32(ecast429);
          this->secondAxis = (MDirection::type)ecast429;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast430;
          xfer += iprot->readI32(ecast430);
          this->thirdAxis = (MDirection::type)ecast430;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_pargs::~MCoordinateSystemMapper_TransformToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_result::~MCoordinateSystemMapper_TransformToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_presult::~MCoordinateSystemMapper_TransformToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_args::~MCoordinateSystemMapper_TransformFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size431;
            ::apache::thrift::protocol::TType _etype434;
            xfer += iprot->readListBegin(_etype434, _size431);
            this->coordinateSystem.resize(_size431);
            uint32_t _i435;
            for (_i435 = 0; _i435 < _size431; ++_i435)
            {
              int32_t ecast436;
              xfer += iprot->readI32(ecast436);
              this->coordinateSystem[_i435] = (MDirection::type)ecast436;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter437;
    for (_iter437 = this->coordinateSystem.begin(); _iter437 != this->coordinateSystem.end(); ++_iter437)
    {
      xfer += oprot->writeI32((int32_t)(*_iter437));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_pargs::~MCoordinateSystemMapper_TransformFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter438;
    for (_iter438 = (*(this->coordinateSystem)).begin(); _iter438 != (*(this->coordinateSystem)).end(); ++_iter438)
    {
      xfer += oprot->writeI32((int32_t)(*_iter438));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_result::~MCoordinateSystemMapper_TransformFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_presult::~MCoordinateSystemMapper_TransformFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_args::~MCoordinateSystemMapper_TransformFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast439;
          xfer += iprot->readI32(ecast439);
          this->firstAxis = (MDirection::type)ecast439;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast440;
          xfer += iprot->readI32(ecast440);
          this->secondAxis = (MDirection::type)ecast440;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast441;
          xfer += iprot->readI32(ecast441);
          this->thirdAxis = (MDirection::type)ecast441;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_pargs::~MCoordinateSystemMapper_TransformFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_result::~MCoordinateSystemMapper_TransformFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_presult::~MCoordinateSystemMapper_TransformFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_args::~MCoordinateSystemMapper_QuaternionToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size442);
            this->coordinateSystem.resize(_size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              int32_t ecast447;
              xfer += iprot->readI32(ecast447);
              this->coordinateSystem[_i446] = (MDirection::type)ecast447;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter448;
    for (_iter448 = this->coordinateSystem.begin(); _iter448 != this->coordinateSystem.end(); ++_iter448)
    {
      xfer += oprot->writeI32((int32_t)(*_iter448));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_pargs::~MCoordinateSystemMapper_QuaternionToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter449;
    for (_iter449 = (*(this->coordinateSystem)).begin(); _iter449 != (*(this->coordinateSystem)).end(); ++_iter449)
    {
      xfer += oprot->writeI32((int32_t)(*_iter449));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_result::~MCoordinateSystemMapper_QuaternionToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_presult::~MCoordinateSystemMapper_QuaternionToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_args::~MCoordinateSystemMapper_QuaternionToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast450;
          xfer += iprot->readI32(ecast450);
          this->firstAxis = (MDirection::type)ecast450;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast451;
          xfer += iprot->readI32(ecast451);
          this->secondAxis = (MDirection::type)ecast451;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast452;
          xfer += iprot->readI32(ecast452);
          this->thirdAxis = (MDirection::type)ecast452;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_pargs::~MCoordinateSystemMapper_QuaternionToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_result::~MCoordinateSystemMapper_QuaternionToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_presult::~MCoordinateSystemMapper_QuaternionToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_args::~MCoordinateSystemMapper_QuaternionFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size453;
            ::apache::thrift::protocol::TType _etype456;
            xfer += iprot->readListBegin(_etype456, _size453);
            this->coordinateSystem.resize(_size453);
            uint32_t _i457;
            for (_i457 = 0; _i457 < _size453; ++_i457)
            {
              int32_t ecast458;
              xfer += iprot->readI32(ecast458);
              this->coordinateSystem[_i457] = (MDirection::type)ecast458;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter459;
    for (_iter459 = this->coordinateSystem.begin(); _iter459 != this->coordinateSystem.end(); ++_iter459)
    {
      xfer += oprot->writeI32((int32_t)(*_iter459));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_pargs::~MCoordinateSystemMapper_QuaternionFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter460;
    for (_iter460 = (*(this->coordinateSystem)).begin(); _iter460 != (*(this->coordinateSystem)).end(); ++_iter460)
    {
      xfer += oprot->writeI32((int32_t)(*_iter460));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_result::~MCoordinateSystemMapper_QuaternionFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_presult::~MCoordinateSystemMapper_QuaternionFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_args::~MCoordinateSystemMapper_QuaternionFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast461;
          xfer += iprot->readI32(ecast461);
          this->firstAxis = (MDirection::type)ecast461;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast462;
          xfer += iprot->readI32(ecast462);
          this->secondAxis = (MDirection::type)ecast462;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast463;
          xfer += iprot->readI32(ecast463);
          this->thirdAxis = (MDirection::type)ecast463;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_pargs::~MCoordinateSystemMapper_QuaternionFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_result::~MCoordinateSystemMapper_QuaternionFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_presult::~MCoordinateSystemMapper_QuaternionFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_args::~MCoordinateSystemMapper_VectorToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size464;
            ::apache::thrift::protocol::TType _etype467;
            xfer += iprot->readListBegin(_etype467, _size464);
            this->coordinateSystem.resize(_size464);
            uint32_t _i468;
            for (_i468 = 0; _i468 < _size464; ++_i468)
            {
              int32_t ecast469;
              xfer += iprot->readI32(ecast469);
              this->coordinateSystem[_i468] = (MDirection::type)ecast469;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter470;
    for (_iter470 = this->coordinateSystem.begin(); _iter470 != this->coordinateSystem.end(); ++_iter470)
    {
      xfer += oprot->writeI32((int32_t)(*_iter470));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_pargs::~MCoordinateSystemMapper_VectorToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter471;
    for (_iter471 = (*(this->coordinateSystem)).begin(); _iter471 != (*(this->coordinateSystem)).end(); ++_iter471)
    {
      xfer += oprot->writeI32((int32_t)(*_iter471));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_result::~MCoordinateSystemMapper_VectorToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_presult::~MCoordinateSystemMapper_VectorToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_args::~MCoordinateSystemMapper_VectorToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast472;
          xfer += iprot->readI32(ecast472);
          this->firstAxis = (MDirection::type)ecast472;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast473;
          xfer += iprot->readI32(ecast473);
          this->secondAxis = (MDirection::type)ecast473;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast474;
          xfer += iprot->readI32(ecast474);
          this->thirdAxis = (MDirection::type)ecast474;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_pargs::~MCoordinateSystemMapper_VectorToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_result::~MCoordinateSystemMapper_VectorToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_presult::~MCoordinateSystemMapper_VectorToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_args::~MCoordinateSystemMapper_VectorFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size475;
            ::apache::thrift::protocol::TType _etype478;
            xfer += iprot->readListBegin(_etype478, _size475);
            this->coordinateSystem.resize(_size475);
            uint32_t _i479;
            for (_i479 = 0; _i479 < _size475; ++_i479)
            {
              int32_t ecast480;
              xfer += iprot->readI32(ecast480);
              this->coordinateSystem[_i479] = (MDirection::type)ecast480;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter481;
    for (_iter481 = this->coordinateSystem.begin(); _iter481 != this->coordinateSystem.end(); ++_iter481)
    {
      xfer += oprot->writeI32((int32_t)(*_iter481));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_pargs::~MCoordinateSystemMapper_VectorFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter482;
    for (_iter482 = (*(this->coordinateSystem)).begin(); _iter482 != (*(this->coordinateSystem)).end(); ++_iter482)
    {
      xfer += oprot->writeI32((int32_t)(*_iter482));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_result::~MCoordinateSystemMapper_VectorFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_presult::~MCoordinateSystemMapper_VectorFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_args::~MCoordinateSystemMapper_VectorFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast483;
          xfer += iprot->readI32(ecast483);
          this->firstAxis = (MDirection::type)ecast483;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast484;
          xfer += iprot->readI32(ecast484);
          this->secondAxis = (MDirection::type)ecast484;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast485;
          xfer += iprot->readI32(ecast485);
          this->thirdAxis = (MDirection::type)ecast485;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_pargs::~MCoordinateSystemMapper_VectorFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_result::~MCoordinateSystemMapper_VectorFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_presult::~MCoordinateSystemMapper_VectorFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void MCoordinateSystemMapperClient::TransformToMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  send_TransformToMMI_L(transform, coordinateSystem);
  recv_TransformToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_TransformToMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformToMMI_L( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformToMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_TransformToMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformToMMI(_return);
}

void MCoordinateSystemMapperClient::send_TransformToMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformToMMI( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformFromMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  send_TransformFromMMI_L(transform, coordinateSystem);
  recv_TransformFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_TransformFromMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformFromMMI_L( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformFromMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_TransformFromMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_TransformFromMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformFromMMI( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_QuaternionToMMI_L(quat, coordinateSystem);
  recv_QuaternionToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionToMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_QuaternionToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionToMMI(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionToMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionToMMI( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_QuaternionFromMMI_L(quat, coordinateSystem);
  recv_QuaternionFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionFromMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_QuaternionFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionFromMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionFromMMI( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorToMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_VectorToMMI_L(quat, coordinateSystem);
  recv_VectorToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_VectorToMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorToMMI_L( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorToMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_VectorToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorToMMI(_return);
}

void MCoordinateSystemMapperClient::send_VectorToMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorToMMI( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorFromMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_VectorFromMMI_L(quat, coordinateSystem);
  recv_VectorFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_VectorFromMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorFromMMI_L( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorFromMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_VectorFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_VectorFromMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorFromMMI( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI failed: unknown result");
}

bool MCoordinateSystemMapperProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return MMIServiceBaseProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void MCoordinateSystemMapperProcessor::process_TransformToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
  }

  MCoordinateSystemMapper_TransformToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformToMMI_L", bytes);
  }

  MCoordinateSystemMapper_TransformToMMI_L_result result;
  try {
    iface_->TransformToMMI_L(result.success, args.transform, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
  }

  oprot->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformToMMI");
  }

  MCoordinateSystemMapper_TransformToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformToMMI", bytes);
  }

  MCoordinateSystemMapper_TransformToMMI_result result;
  try {
    iface_->TransformToMMI(result.success, args.transform, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformToMMI");
  }

  oprot->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
  }

  MCoordinateSystemMapper_TransformFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_TransformFromMMI_L_result result;
  try {
    iface_->TransformFromMMI_L(result.success, args.transform, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
  }

  oprot->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformFromMMI");
  }

  MCoordinateSystemMapper_TransformFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformFromMMI", bytes);
  }

  MCoordinateSystemMapper_TransformFromMMI_result result;
  try {
    iface_->TransformFromMMI(result.success, args.transform, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI");
  }

  oprot->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
  }

  MCoordinateSystemMapper_QuaternionToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L", bytes);
  }

  MCoordinateSystemMapper_QuaternionToMMI_L_result result;
  try {
    iface_->QuaternionToMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
  }

  oprot->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
  }

  MCoordinateSystemMapper_QuaternionToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI", bytes);
  }

  MCoordinateSystemMapper_QuaternionToMMI_result result;
  try {
    iface_->QuaternionToMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
  }

  oprot->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
  }

  MCoordinateSystemMapper_QuaternionFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_QuaternionFromMMI_L_result result;
  try {
    iface_->QuaternionFromMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
  }

  oprot->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
  }

  MCoordinateSystemMapper_QuaternionFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI", bytes);
  }

  MCoordinateSystemMapper_QuaternionFromMMI_result result;
  try {
    iface_->QuaternionFromMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
  }

  oprot->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
  }

  MCoordinateSystemMapper_VectorToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorToMMI_L", bytes);
  }

  MCoordinateSystemMapper_VectorToMMI_L_result result;
  try {
    iface_->VectorToMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
  }

  oprot->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorToMMI");
  }

  MCoordinateSystemMapper_VectorToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorToMMI", bytes);
  }

  MCoordinateSystemMapper_VectorToMMI_result result;
  try {
    iface_->VectorToMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorToMMI");
  }

  oprot->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
  }

  MCoordinateSystemMapper_VectorFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_VectorFromMMI_L_result result;
  try {
    iface_->VectorFromMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
  }

  oprot->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorFromMMI");
  }

  MCoordinateSystemMapper_VectorFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorFromMMI", bytes);
  }

  MCoordinateSystemMapper_VectorFromMMI_result result;
  try {
    iface_->VectorFromMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI");
  }

  oprot->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > MCoordinateSystemMapperProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< MCoordinateSystemMapperIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< MCoordinateSystemMapperIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new MCoordinateSystemMapperProcessor(handler));
  return processor;
}

void MCoordinateSystemMapperConcurrentClient::TransformToMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_TransformToMMI_L(transform, coordinateSystem);
  recv_TransformToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformToMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformToMMI_L( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformToMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_TransformToMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformToMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformToMMI( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformFromMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_TransformFromMMI_L(transform, coordinateSystem);
  recv_TransformFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformFromMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformFromMMI_L( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformFromMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_TransformFromMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformFromMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformFromMMI( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_QuaternionToMMI_L(quat, coordinateSystem);
  recv_QuaternionToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionToMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_QuaternionToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionToMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_QuaternionFromMMI_L(quat, coordinateSystem);
  recv_QuaternionFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionFromMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_QuaternionFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionFromMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorToMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_VectorToMMI_L(quat, coordinateSystem);
  recv_VectorToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorToMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorToMMI_L( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorToMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_VectorToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorToMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorToMMI( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorFromMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_VectorFromMMI_L(quat, coordinateSystem);
  recv_VectorFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorFromMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorFromMMI_L( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorFromMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_VectorFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorFromMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorFromMMI( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

