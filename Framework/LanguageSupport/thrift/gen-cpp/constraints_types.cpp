/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "constraints_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {

int _kMTranslationConstraintTypeValues[] = {
  MTranslationConstraintType::BOX,
  MTranslationConstraintType::ELLIPSOID
};
const char* _kMTranslationConstraintTypeNames[] = {
  "BOX",
  "ELLIPSOID"
};
const std::map<int, const char*> _MTranslationConstraintType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMTranslationConstraintTypeValues, _kMTranslationConstraintTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MTranslationConstraintType::type& val) {
  std::map<int, const char*>::const_iterator it = _MTranslationConstraintType_VALUES_TO_NAMES.find(val);
  if (it != _MTranslationConstraintType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MTranslationConstraintType::type& val) {
  std::map<int, const char*>::const_iterator it = _MTranslationConstraintType_VALUES_TO_NAMES.find(val);
  if (it != _MTranslationConstraintType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


MConstraint::~MConstraint() noexcept {
}


void MConstraint::__set_ID(const std::string& val) {
  this->ID = val;
}

void MConstraint::__set_GeometryConstraint(const MGeometryConstraint& val) {
  this->GeometryConstraint = val;
__isset.GeometryConstraint = true;
}

void MConstraint::__set_VelocityConstraint(const MVelocityConstraint& val) {
  this->VelocityConstraint = val;
__isset.VelocityConstraint = true;
}

void MConstraint::__set_AccelerationConstraint(const MAccelerationConstraint& val) {
  this->AccelerationConstraint = val;
__isset.AccelerationConstraint = true;
}

void MConstraint::__set_PathConstraint(const MPathConstraint& val) {
  this->PathConstraint = val;
__isset.PathConstraint = true;
}

void MConstraint::__set_JointPathConstraint(const MJointPathConstraint& val) {
  this->JointPathConstraint = val;
__isset.JointPathConstraint = true;
}

void MConstraint::__set_PostureConstraint(const MPostureConstraint& val) {
  this->PostureConstraint = val;
__isset.PostureConstraint = true;
}

void MConstraint::__set_JointConstraint(const MJointConstraint& val) {
  this->JointConstraint = val;
__isset.JointConstraint = true;
}

void MConstraint::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->GeometryConstraint.read(iprot);
          this->__isset.GeometryConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->VelocityConstraint.read(iprot);
          this->__isset.VelocityConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AccelerationConstraint.read(iprot);
          this->__isset.AccelerationConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PathConstraint.read(iprot);
          this->__isset.PathConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->JointPathConstraint.read(iprot);
          this->__isset.JointPathConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PostureConstraint.read(iprot);
          this->__isset.PostureConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->JointConstraint.read(iprot);
          this->__isset.JointConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->Properties[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MConstraint");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.GeometryConstraint) {
    xfer += oprot->writeFieldBegin("GeometryConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->GeometryConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.VelocityConstraint) {
    xfer += oprot->writeFieldBegin("VelocityConstraint", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->VelocityConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AccelerationConstraint) {
    xfer += oprot->writeFieldBegin("AccelerationConstraint", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->AccelerationConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PathConstraint) {
    xfer += oprot->writeFieldBegin("PathConstraint", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->PathConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.JointPathConstraint) {
    xfer += oprot->writeFieldBegin("JointPathConstraint", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->JointPathConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PostureConstraint) {
    xfer += oprot->writeFieldBegin("PostureConstraint", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->PostureConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.JointConstraint) {
    xfer += oprot->writeFieldBegin("JointConstraint", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->JointConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->Properties.begin(); _iter7 != this->Properties.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MConstraint &a, MConstraint &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.GeometryConstraint, b.GeometryConstraint);
  swap(a.VelocityConstraint, b.VelocityConstraint);
  swap(a.AccelerationConstraint, b.AccelerationConstraint);
  swap(a.PathConstraint, b.PathConstraint);
  swap(a.JointPathConstraint, b.JointPathConstraint);
  swap(a.PostureConstraint, b.PostureConstraint);
  swap(a.JointConstraint, b.JointConstraint);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MConstraint::MConstraint(const MConstraint& other8) {
  ID = other8.ID;
  GeometryConstraint = other8.GeometryConstraint;
  VelocityConstraint = other8.VelocityConstraint;
  AccelerationConstraint = other8.AccelerationConstraint;
  PathConstraint = other8.PathConstraint;
  JointPathConstraint = other8.JointPathConstraint;
  PostureConstraint = other8.PostureConstraint;
  JointConstraint = other8.JointConstraint;
  Properties = other8.Properties;
  __isset = other8.__isset;
}
MConstraint& MConstraint::operator=(const MConstraint& other9) {
  ID = other9.ID;
  GeometryConstraint = other9.GeometryConstraint;
  VelocityConstraint = other9.VelocityConstraint;
  AccelerationConstraint = other9.AccelerationConstraint;
  PathConstraint = other9.PathConstraint;
  JointPathConstraint = other9.JointPathConstraint;
  PostureConstraint = other9.PostureConstraint;
  JointConstraint = other9.JointConstraint;
  Properties = other9.Properties;
  __isset = other9.__isset;
  return *this;
}
void MConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MConstraint(";
  out << "ID=" << to_string(ID);
  out << ", " << "GeometryConstraint="; (__isset.GeometryConstraint ? (out << to_string(GeometryConstraint)) : (out << "<null>"));
  out << ", " << "VelocityConstraint="; (__isset.VelocityConstraint ? (out << to_string(VelocityConstraint)) : (out << "<null>"));
  out << ", " << "AccelerationConstraint="; (__isset.AccelerationConstraint ? (out << to_string(AccelerationConstraint)) : (out << "<null>"));
  out << ", " << "PathConstraint="; (__isset.PathConstraint ? (out << to_string(PathConstraint)) : (out << "<null>"));
  out << ", " << "JointPathConstraint="; (__isset.JointPathConstraint ? (out << to_string(JointPathConstraint)) : (out << "<null>"));
  out << ", " << "PostureConstraint="; (__isset.PostureConstraint ? (out << to_string(PostureConstraint)) : (out << "<null>"));
  out << ", " << "JointConstraint="; (__isset.JointConstraint ? (out << to_string(JointConstraint)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MInterval::~MInterval() noexcept {
}


void MInterval::__set_Min(const double val) {
  this->Min = val;
}

void MInterval::__set_Max(const double val) {
  this->Max = val;
}
std::ostream& operator<<(std::ostream& out, const MInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Min = false;
  bool isset_Max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Min);
          isset_Min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Max);
          isset_Max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Min)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MInterval");

  xfer += oprot->writeFieldBegin("Min", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Max", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MInterval &a, MInterval &b) {
  using ::std::swap;
  swap(a.Min, b.Min);
  swap(a.Max, b.Max);
}

MInterval::MInterval(const MInterval& other10) {
  Min = other10.Min;
  Max = other10.Max;
}
MInterval& MInterval::operator=(const MInterval& other11) {
  Min = other11.Min;
  Max = other11.Max;
  return *this;
}
void MInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MInterval(";
  out << "Min=" << to_string(Min);
  out << ", " << "Max=" << to_string(Max);
  out << ")";
}


MInterval3::~MInterval3() noexcept {
}


void MInterval3::__set_X(const MInterval& val) {
  this->X = val;
}

void MInterval3::__set_Y(const MInterval& val) {
  this->Y = val;
}

void MInterval3::__set_Z(const MInterval& val) {
  this->Z = val;
}
std::ostream& operator<<(std::ostream& out, const MInterval3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MInterval3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_X = false;
  bool isset_Y = false;
  bool isset_Z = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->X.read(iprot);
          isset_X = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Y.read(iprot);
          isset_Y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Z.read(iprot);
          isset_Z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_X)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MInterval3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MInterval3");

  xfer += oprot->writeFieldBegin("X", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->X.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Y", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->Y.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Z", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->Z.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MInterval3 &a, MInterval3 &b) {
  using ::std::swap;
  swap(a.X, b.X);
  swap(a.Y, b.Y);
  swap(a.Z, b.Z);
}

MInterval3::MInterval3(const MInterval3& other12) {
  X = other12.X;
  Y = other12.Y;
  Z = other12.Z;
}
MInterval3& MInterval3::operator=(const MInterval3& other13) {
  X = other13.X;
  Y = other13.Y;
  Z = other13.Z;
  return *this;
}
void MInterval3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MInterval3(";
  out << "X=" << to_string(X);
  out << ", " << "Y=" << to_string(Y);
  out << ", " << "Z=" << to_string(Z);
  out << ")";
}


MTranslationConstraint::~MTranslationConstraint() noexcept {
}


void MTranslationConstraint::__set_Type(const MTranslationConstraintType::type val) {
  this->Type = val;
}

void MTranslationConstraint::__set_Limits(const MInterval3& val) {
  this->Limits = val;
}
std::ostream& operator<<(std::ostream& out, const MTranslationConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTranslationConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Type = false;
  bool isset_Limits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->Type = (MTranslationConstraintType::type)ecast14;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Limits.read(iprot);
          isset_Limits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Limits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MTranslationConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTranslationConstraint");

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Limits", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->Limits.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTranslationConstraint &a, MTranslationConstraint &b) {
  using ::std::swap;
  swap(a.Type, b.Type);
  swap(a.Limits, b.Limits);
}

MTranslationConstraint::MTranslationConstraint(const MTranslationConstraint& other15) {
  Type = other15.Type;
  Limits = other15.Limits;
}
MTranslationConstraint& MTranslationConstraint::operator=(const MTranslationConstraint& other16) {
  Type = other16.Type;
  Limits = other16.Limits;
  return *this;
}
void MTranslationConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTranslationConstraint(";
  out << "Type=" << to_string(Type);
  out << ", " << "Limits=" << to_string(Limits);
  out << ")";
}


MRotationConstraint::~MRotationConstraint() noexcept {
}


void MRotationConstraint::__set_Limits(const MInterval3& val) {
  this->Limits = val;
}
std::ostream& operator<<(std::ostream& out, const MRotationConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MRotationConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Limits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Limits.read(iprot);
          isset_Limits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Limits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MRotationConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MRotationConstraint");

  xfer += oprot->writeFieldBegin("Limits", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->Limits.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MRotationConstraint &a, MRotationConstraint &b) {
  using ::std::swap;
  swap(a.Limits, b.Limits);
}

MRotationConstraint::MRotationConstraint(const MRotationConstraint& other17) {
  Limits = other17.Limits;
}
MRotationConstraint& MRotationConstraint::operator=(const MRotationConstraint& other18) {
  Limits = other18.Limits;
  return *this;
}
void MRotationConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MRotationConstraint(";
  out << "Limits=" << to_string(Limits);
  out << ")";
}


MGeometryConstraint::~MGeometryConstraint() noexcept {
}


void MGeometryConstraint::__set_ParentObjectID(const std::string& val) {
  this->ParentObjectID = val;
}

void MGeometryConstraint::__set_ParentToConstraint(const  ::MMIStandard::MTransform& val) {
  this->ParentToConstraint = val;
__isset.ParentToConstraint = true;
}

void MGeometryConstraint::__set_TranslationConstraint(const MTranslationConstraint& val) {
  this->TranslationConstraint = val;
__isset.TranslationConstraint = true;
}

void MGeometryConstraint::__set_RotationConstraint(const MRotationConstraint& val) {
  this->RotationConstraint = val;
__isset.RotationConstraint = true;
}

void MGeometryConstraint::__set_WeightingFactor(const double val) {
  this->WeightingFactor = val;
__isset.WeightingFactor = true;
}
std::ostream& operator<<(std::ostream& out, const MGeometryConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MGeometryConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ParentObjectID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ParentObjectID);
          isset_ParentObjectID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ParentToConstraint.read(iprot);
          this->__isset.ParentToConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TranslationConstraint.read(iprot);
          this->__isset.TranslationConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->RotationConstraint.read(iprot);
          this->__isset.RotationConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->WeightingFactor);
          this->__isset.WeightingFactor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ParentObjectID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MGeometryConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MGeometryConstraint");

  xfer += oprot->writeFieldBegin("ParentObjectID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ParentObjectID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ParentToConstraint) {
    xfer += oprot->writeFieldBegin("ParentToConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ParentToConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TranslationConstraint) {
    xfer += oprot->writeFieldBegin("TranslationConstraint", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->TranslationConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RotationConstraint) {
    xfer += oprot->writeFieldBegin("RotationConstraint", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->RotationConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.WeightingFactor) {
    xfer += oprot->writeFieldBegin("WeightingFactor", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->WeightingFactor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MGeometryConstraint &a, MGeometryConstraint &b) {
  using ::std::swap;
  swap(a.ParentObjectID, b.ParentObjectID);
  swap(a.ParentToConstraint, b.ParentToConstraint);
  swap(a.TranslationConstraint, b.TranslationConstraint);
  swap(a.RotationConstraint, b.RotationConstraint);
  swap(a.WeightingFactor, b.WeightingFactor);
  swap(a.__isset, b.__isset);
}

MGeometryConstraint::MGeometryConstraint(const MGeometryConstraint& other19) {
  ParentObjectID = other19.ParentObjectID;
  ParentToConstraint = other19.ParentToConstraint;
  TranslationConstraint = other19.TranslationConstraint;
  RotationConstraint = other19.RotationConstraint;
  WeightingFactor = other19.WeightingFactor;
  __isset = other19.__isset;
}
MGeometryConstraint& MGeometryConstraint::operator=(const MGeometryConstraint& other20) {
  ParentObjectID = other20.ParentObjectID;
  ParentToConstraint = other20.ParentToConstraint;
  TranslationConstraint = other20.TranslationConstraint;
  RotationConstraint = other20.RotationConstraint;
  WeightingFactor = other20.WeightingFactor;
  __isset = other20.__isset;
  return *this;
}
void MGeometryConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MGeometryConstraint(";
  out << "ParentObjectID=" << to_string(ParentObjectID);
  out << ", " << "ParentToConstraint="; (__isset.ParentToConstraint ? (out << to_string(ParentToConstraint)) : (out << "<null>"));
  out << ", " << "TranslationConstraint="; (__isset.TranslationConstraint ? (out << to_string(TranslationConstraint)) : (out << "<null>"));
  out << ", " << "RotationConstraint="; (__isset.RotationConstraint ? (out << to_string(RotationConstraint)) : (out << "<null>"));
  out << ", " << "WeightingFactor="; (__isset.WeightingFactor ? (out << to_string(WeightingFactor)) : (out << "<null>"));
  out << ")";
}


MVelocityConstraint::~MVelocityConstraint() noexcept {
}


void MVelocityConstraint::__set_ParentObjectID(const std::string& val) {
  this->ParentObjectID = val;
}

void MVelocityConstraint::__set_ParentToConstraint(const  ::MMIStandard::MTransform& val) {
  this->ParentToConstraint = val;
__isset.ParentToConstraint = true;
}

void MVelocityConstraint::__set_TranslationalVelocity(const  ::MMIStandard::MVector3& val) {
  this->TranslationalVelocity = val;
__isset.TranslationalVelocity = true;
}

void MVelocityConstraint::__set_RotationalVelocity(const  ::MMIStandard::MVector3& val) {
  this->RotationalVelocity = val;
__isset.RotationalVelocity = true;
}

void MVelocityConstraint::__set_WeightingFactor(const double val) {
  this->WeightingFactor = val;
__isset.WeightingFactor = true;
}
std::ostream& operator<<(std::ostream& out, const MVelocityConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MVelocityConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ParentObjectID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ParentObjectID);
          isset_ParentObjectID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ParentToConstraint.read(iprot);
          this->__isset.ParentToConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TranslationalVelocity.read(iprot);
          this->__isset.TranslationalVelocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->RotationalVelocity.read(iprot);
          this->__isset.RotationalVelocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->WeightingFactor);
          this->__isset.WeightingFactor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ParentObjectID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MVelocityConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MVelocityConstraint");

  xfer += oprot->writeFieldBegin("ParentObjectID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ParentObjectID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ParentToConstraint) {
    xfer += oprot->writeFieldBegin("ParentToConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ParentToConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TranslationalVelocity) {
    xfer += oprot->writeFieldBegin("TranslationalVelocity", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->TranslationalVelocity.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RotationalVelocity) {
    xfer += oprot->writeFieldBegin("RotationalVelocity", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->RotationalVelocity.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.WeightingFactor) {
    xfer += oprot->writeFieldBegin("WeightingFactor", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->WeightingFactor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MVelocityConstraint &a, MVelocityConstraint &b) {
  using ::std::swap;
  swap(a.ParentObjectID, b.ParentObjectID);
  swap(a.ParentToConstraint, b.ParentToConstraint);
  swap(a.TranslationalVelocity, b.TranslationalVelocity);
  swap(a.RotationalVelocity, b.RotationalVelocity);
  swap(a.WeightingFactor, b.WeightingFactor);
  swap(a.__isset, b.__isset);
}

MVelocityConstraint::MVelocityConstraint(const MVelocityConstraint& other21) {
  ParentObjectID = other21.ParentObjectID;
  ParentToConstraint = other21.ParentToConstraint;
  TranslationalVelocity = other21.TranslationalVelocity;
  RotationalVelocity = other21.RotationalVelocity;
  WeightingFactor = other21.WeightingFactor;
  __isset = other21.__isset;
}
MVelocityConstraint& MVelocityConstraint::operator=(const MVelocityConstraint& other22) {
  ParentObjectID = other22.ParentObjectID;
  ParentToConstraint = other22.ParentToConstraint;
  TranslationalVelocity = other22.TranslationalVelocity;
  RotationalVelocity = other22.RotationalVelocity;
  WeightingFactor = other22.WeightingFactor;
  __isset = other22.__isset;
  return *this;
}
void MVelocityConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MVelocityConstraint(";
  out << "ParentObjectID=" << to_string(ParentObjectID);
  out << ", " << "ParentToConstraint="; (__isset.ParentToConstraint ? (out << to_string(ParentToConstraint)) : (out << "<null>"));
  out << ", " << "TranslationalVelocity="; (__isset.TranslationalVelocity ? (out << to_string(TranslationalVelocity)) : (out << "<null>"));
  out << ", " << "RotationalVelocity="; (__isset.RotationalVelocity ? (out << to_string(RotationalVelocity)) : (out << "<null>"));
  out << ", " << "WeightingFactor="; (__isset.WeightingFactor ? (out << to_string(WeightingFactor)) : (out << "<null>"));
  out << ")";
}


MAccelerationConstraint::~MAccelerationConstraint() noexcept {
}


void MAccelerationConstraint::__set_ParentObjectID(const std::string& val) {
  this->ParentObjectID = val;
}

void MAccelerationConstraint::__set_ParentToConstraint(const  ::MMIStandard::MTransform& val) {
  this->ParentToConstraint = val;
__isset.ParentToConstraint = true;
}

void MAccelerationConstraint::__set_TranslationalAcceleration(const  ::MMIStandard::MVector3& val) {
  this->TranslationalAcceleration = val;
__isset.TranslationalAcceleration = true;
}

void MAccelerationConstraint::__set_RotationalAcceleration(const  ::MMIStandard::MVector3& val) {
  this->RotationalAcceleration = val;
__isset.RotationalAcceleration = true;
}

void MAccelerationConstraint::__set_WeightingFactor(const double val) {
  this->WeightingFactor = val;
__isset.WeightingFactor = true;
}
std::ostream& operator<<(std::ostream& out, const MAccelerationConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAccelerationConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ParentObjectID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ParentObjectID);
          isset_ParentObjectID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ParentToConstraint.read(iprot);
          this->__isset.ParentToConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TranslationalAcceleration.read(iprot);
          this->__isset.TranslationalAcceleration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->RotationalAcceleration.read(iprot);
          this->__isset.RotationalAcceleration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->WeightingFactor);
          this->__isset.WeightingFactor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ParentObjectID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAccelerationConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAccelerationConstraint");

  xfer += oprot->writeFieldBegin("ParentObjectID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ParentObjectID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ParentToConstraint) {
    xfer += oprot->writeFieldBegin("ParentToConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ParentToConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TranslationalAcceleration) {
    xfer += oprot->writeFieldBegin("TranslationalAcceleration", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->TranslationalAcceleration.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RotationalAcceleration) {
    xfer += oprot->writeFieldBegin("RotationalAcceleration", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->RotationalAcceleration.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.WeightingFactor) {
    xfer += oprot->writeFieldBegin("WeightingFactor", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->WeightingFactor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAccelerationConstraint &a, MAccelerationConstraint &b) {
  using ::std::swap;
  swap(a.ParentObjectID, b.ParentObjectID);
  swap(a.ParentToConstraint, b.ParentToConstraint);
  swap(a.TranslationalAcceleration, b.TranslationalAcceleration);
  swap(a.RotationalAcceleration, b.RotationalAcceleration);
  swap(a.WeightingFactor, b.WeightingFactor);
  swap(a.__isset, b.__isset);
}

MAccelerationConstraint::MAccelerationConstraint(const MAccelerationConstraint& other23) {
  ParentObjectID = other23.ParentObjectID;
  ParentToConstraint = other23.ParentToConstraint;
  TranslationalAcceleration = other23.TranslationalAcceleration;
  RotationalAcceleration = other23.RotationalAcceleration;
  WeightingFactor = other23.WeightingFactor;
  __isset = other23.__isset;
}
MAccelerationConstraint& MAccelerationConstraint::operator=(const MAccelerationConstraint& other24) {
  ParentObjectID = other24.ParentObjectID;
  ParentToConstraint = other24.ParentToConstraint;
  TranslationalAcceleration = other24.TranslationalAcceleration;
  RotationalAcceleration = other24.RotationalAcceleration;
  WeightingFactor = other24.WeightingFactor;
  __isset = other24.__isset;
  return *this;
}
void MAccelerationConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAccelerationConstraint(";
  out << "ParentObjectID=" << to_string(ParentObjectID);
  out << ", " << "ParentToConstraint="; (__isset.ParentToConstraint ? (out << to_string(ParentToConstraint)) : (out << "<null>"));
  out << ", " << "TranslationalAcceleration="; (__isset.TranslationalAcceleration ? (out << to_string(TranslationalAcceleration)) : (out << "<null>"));
  out << ", " << "RotationalAcceleration="; (__isset.RotationalAcceleration ? (out << to_string(RotationalAcceleration)) : (out << "<null>"));
  out << ", " << "WeightingFactor="; (__isset.WeightingFactor ? (out << to_string(WeightingFactor)) : (out << "<null>"));
  out << ")";
}


MPathConstraint::~MPathConstraint() noexcept {
}


void MPathConstraint::__set_PolygonPoints(const std::vector<MGeometryConstraint> & val) {
  this->PolygonPoints = val;
}

void MPathConstraint::__set_WeightingFactor(const double val) {
  this->WeightingFactor = val;
__isset.WeightingFactor = true;
}
std::ostream& operator<<(std::ostream& out, const MPathConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPathConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_PolygonPoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->PolygonPoints.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->PolygonPoints.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->PolygonPoints[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_PolygonPoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->WeightingFactor);
          this->__isset.WeightingFactor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_PolygonPoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPathConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPathConstraint");

  xfer += oprot->writeFieldBegin("PolygonPoints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->PolygonPoints.size()));
    std::vector<MGeometryConstraint> ::const_iterator _iter30;
    for (_iter30 = this->PolygonPoints.begin(); _iter30 != this->PolygonPoints.end(); ++_iter30)
    {
      xfer += (*_iter30).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.WeightingFactor) {
    xfer += oprot->writeFieldBegin("WeightingFactor", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->WeightingFactor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPathConstraint &a, MPathConstraint &b) {
  using ::std::swap;
  swap(a.PolygonPoints, b.PolygonPoints);
  swap(a.WeightingFactor, b.WeightingFactor);
  swap(a.__isset, b.__isset);
}

MPathConstraint::MPathConstraint(const MPathConstraint& other31) {
  PolygonPoints = other31.PolygonPoints;
  WeightingFactor = other31.WeightingFactor;
  __isset = other31.__isset;
}
MPathConstraint& MPathConstraint::operator=(const MPathConstraint& other32) {
  PolygonPoints = other32.PolygonPoints;
  WeightingFactor = other32.WeightingFactor;
  __isset = other32.__isset;
  return *this;
}
void MPathConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPathConstraint(";
  out << "PolygonPoints=" << to_string(PolygonPoints);
  out << ", " << "WeightingFactor="; (__isset.WeightingFactor ? (out << to_string(WeightingFactor)) : (out << "<null>"));
  out << ")";
}


MJointConstraint::~MJointConstraint() noexcept {
}


void MJointConstraint::__set_JointType(const  ::MMIStandard::MJointType::type val) {
  this->JointType = val;
}

void MJointConstraint::__set_GeometryConstraint(const MGeometryConstraint& val) {
  this->GeometryConstraint = val;
__isset.GeometryConstraint = true;
}

void MJointConstraint::__set_VelocityConstraint(const MVelocityConstraint& val) {
  this->VelocityConstraint = val;
__isset.VelocityConstraint = true;
}

void MJointConstraint::__set_AccelerationConstraint(const MAccelerationConstraint& val) {
  this->AccelerationConstraint = val;
__isset.AccelerationConstraint = true;
}
std::ostream& operator<<(std::ostream& out, const MJointConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MJointConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_JointType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->JointType = ( ::MMIStandard::MJointType::type)ecast33;
          isset_JointType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->GeometryConstraint.read(iprot);
          this->__isset.GeometryConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->VelocityConstraint.read(iprot);
          this->__isset.VelocityConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AccelerationConstraint.read(iprot);
          this->__isset.AccelerationConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_JointType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MJointConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MJointConstraint");

  xfer += oprot->writeFieldBegin("JointType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->JointType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.GeometryConstraint) {
    xfer += oprot->writeFieldBegin("GeometryConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->GeometryConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.VelocityConstraint) {
    xfer += oprot->writeFieldBegin("VelocityConstraint", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->VelocityConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AccelerationConstraint) {
    xfer += oprot->writeFieldBegin("AccelerationConstraint", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->AccelerationConstraint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MJointConstraint &a, MJointConstraint &b) {
  using ::std::swap;
  swap(a.JointType, b.JointType);
  swap(a.GeometryConstraint, b.GeometryConstraint);
  swap(a.VelocityConstraint, b.VelocityConstraint);
  swap(a.AccelerationConstraint, b.AccelerationConstraint);
  swap(a.__isset, b.__isset);
}

MJointConstraint::MJointConstraint(const MJointConstraint& other34) {
  JointType = other34.JointType;
  GeometryConstraint = other34.GeometryConstraint;
  VelocityConstraint = other34.VelocityConstraint;
  AccelerationConstraint = other34.AccelerationConstraint;
  __isset = other34.__isset;
}
MJointConstraint& MJointConstraint::operator=(const MJointConstraint& other35) {
  JointType = other35.JointType;
  GeometryConstraint = other35.GeometryConstraint;
  VelocityConstraint = other35.VelocityConstraint;
  AccelerationConstraint = other35.AccelerationConstraint;
  __isset = other35.__isset;
  return *this;
}
void MJointConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MJointConstraint(";
  out << "JointType=" << to_string(JointType);
  out << ", " << "GeometryConstraint="; (__isset.GeometryConstraint ? (out << to_string(GeometryConstraint)) : (out << "<null>"));
  out << ", " << "VelocityConstraint="; (__isset.VelocityConstraint ? (out << to_string(VelocityConstraint)) : (out << "<null>"));
  out << ", " << "AccelerationConstraint="; (__isset.AccelerationConstraint ? (out << to_string(AccelerationConstraint)) : (out << "<null>"));
  out << ")";
}


MJointPathConstraint::~MJointPathConstraint() noexcept {
}


void MJointPathConstraint::__set_JointType(const  ::MMIStandard::MJointType::type val) {
  this->JointType = val;
}

void MJointPathConstraint::__set_PathConstraint(const MPathConstraint& val) {
  this->PathConstraint = val;
}
std::ostream& operator<<(std::ostream& out, const MJointPathConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MJointPathConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_JointType = false;
  bool isset_PathConstraint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast36;
          xfer += iprot->readI32(ecast36);
          this->JointType = ( ::MMIStandard::MJointType::type)ecast36;
          isset_JointType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PathConstraint.read(iprot);
          isset_PathConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_JointType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_PathConstraint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MJointPathConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MJointPathConstraint");

  xfer += oprot->writeFieldBegin("JointType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->JointType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PathConstraint", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->PathConstraint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MJointPathConstraint &a, MJointPathConstraint &b) {
  using ::std::swap;
  swap(a.JointType, b.JointType);
  swap(a.PathConstraint, b.PathConstraint);
}

MJointPathConstraint::MJointPathConstraint(const MJointPathConstraint& other37) {
  JointType = other37.JointType;
  PathConstraint = other37.PathConstraint;
}
MJointPathConstraint& MJointPathConstraint::operator=(const MJointPathConstraint& other38) {
  JointType = other38.JointType;
  PathConstraint = other38.PathConstraint;
  return *this;
}
void MJointPathConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MJointPathConstraint(";
  out << "JointType=" << to_string(JointType);
  out << ", " << "PathConstraint=" << to_string(PathConstraint);
  out << ")";
}


MPostureConstraint::~MPostureConstraint() noexcept {
}


void MPostureConstraint::__set_posture(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->posture = val;
}

void MPostureConstraint::__set_JointConstraints(const std::vector<MJointConstraint> & val) {
  this->JointConstraints = val;
__isset.JointConstraints = true;
}
std::ostream& operator<<(std::ostream& out, const MPostureConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPostureConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_posture = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->posture.read(iprot);
          isset_posture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->JointConstraints.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->JointConstraints.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->JointConstraints[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.JointConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_posture)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPostureConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPostureConstraint");

  xfer += oprot->writeFieldBegin("posture", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->posture.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.JointConstraints) {
    xfer += oprot->writeFieldBegin("JointConstraints", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->JointConstraints.size()));
      std::vector<MJointConstraint> ::const_iterator _iter44;
      for (_iter44 = this->JointConstraints.begin(); _iter44 != this->JointConstraints.end(); ++_iter44)
      {
        xfer += (*_iter44).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPostureConstraint &a, MPostureConstraint &b) {
  using ::std::swap;
  swap(a.posture, b.posture);
  swap(a.JointConstraints, b.JointConstraints);
  swap(a.__isset, b.__isset);
}

MPostureConstraint::MPostureConstraint(const MPostureConstraint& other45) {
  posture = other45.posture;
  JointConstraints = other45.JointConstraints;
  __isset = other45.__isset;
}
MPostureConstraint& MPostureConstraint::operator=(const MPostureConstraint& other46) {
  posture = other46.posture;
  JointConstraints = other46.JointConstraints;
  __isset = other46.__isset;
  return *this;
}
void MPostureConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPostureConstraint(";
  out << "posture=" << to_string(posture);
  out << ", " << "JointConstraints="; (__isset.JointConstraints ? (out << to_string(JointConstraints)) : (out << "<null>"));
  out << ")";
}

} // namespace
