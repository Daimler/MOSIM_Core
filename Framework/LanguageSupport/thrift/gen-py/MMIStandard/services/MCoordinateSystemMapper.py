#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import MMIStandard.services.MMIServiceBase
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(MMIStandard.services.MMIServiceBase.Iface):
    def TransformToMMI_L(self, transform, coordinateSystem):
        """
        Parameters:
         - transform
         - coordinateSystem

        """
        pass

    def TransformToMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - transform
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass

    def TransformFromMMI_L(self, transform, coordinateSystem):
        """
        Parameters:
         - transform
         - coordinateSystem

        """
        pass

    def TransformFromMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - transform
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass

    def QuaternionToMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        pass

    def QuaternionToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass

    def QuaternionFromMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        pass

    def QuaternionFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass

    def VectorToMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        pass

    def VectorToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass

    def VectorFromMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        pass

    def VectorFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        pass


class Client(MMIStandard.services.MMIServiceBase.Client, Iface):
    def __init__(self, iprot, oprot=None):
        MMIStandard.services.MMIServiceBase.Client.__init__(self, iprot, oprot)

    def TransformToMMI_L(self, transform, coordinateSystem):
        """
        Parameters:
         - transform
         - coordinateSystem

        """
        self.send_TransformToMMI_L(transform, coordinateSystem)
        return self.recv_TransformToMMI_L()

    def send_TransformToMMI_L(self, transform, coordinateSystem):
        self._oprot.writeMessageBegin('TransformToMMI_L', TMessageType.CALL, self._seqid)
        args = TransformToMMI_L_args()
        args.transform = transform
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_TransformToMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = TransformToMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "TransformToMMI_L failed: unknown result")

    def TransformToMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - transform
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_TransformToMMI(transform, firstAxis, secondAxis, thirdAxis)
        return self.recv_TransformToMMI()

    def send_TransformToMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('TransformToMMI', TMessageType.CALL, self._seqid)
        args = TransformToMMI_args()
        args.transform = transform
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_TransformToMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = TransformToMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "TransformToMMI failed: unknown result")

    def TransformFromMMI_L(self, transform, coordinateSystem):
        """
        Parameters:
         - transform
         - coordinateSystem

        """
        self.send_TransformFromMMI_L(transform, coordinateSystem)
        return self.recv_TransformFromMMI_L()

    def send_TransformFromMMI_L(self, transform, coordinateSystem):
        self._oprot.writeMessageBegin('TransformFromMMI_L', TMessageType.CALL, self._seqid)
        args = TransformFromMMI_L_args()
        args.transform = transform
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_TransformFromMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = TransformFromMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "TransformFromMMI_L failed: unknown result")

    def TransformFromMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - transform
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_TransformFromMMI(transform, firstAxis, secondAxis, thirdAxis)
        return self.recv_TransformFromMMI()

    def send_TransformFromMMI(self, transform, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('TransformFromMMI', TMessageType.CALL, self._seqid)
        args = TransformFromMMI_args()
        args.transform = transform
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_TransformFromMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = TransformFromMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "TransformFromMMI failed: unknown result")

    def QuaternionToMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        self.send_QuaternionToMMI_L(quat, coordinateSystem)
        return self.recv_QuaternionToMMI_L()

    def send_QuaternionToMMI_L(self, quat, coordinateSystem):
        self._oprot.writeMessageBegin('QuaternionToMMI_L', TMessageType.CALL, self._seqid)
        args = QuaternionToMMI_L_args()
        args.quat = quat
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QuaternionToMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QuaternionToMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QuaternionToMMI_L failed: unknown result")

    def QuaternionToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_QuaternionToMMI(quat, firstAxis, secondAxis, thirdAxis)
        return self.recv_QuaternionToMMI()

    def send_QuaternionToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('QuaternionToMMI', TMessageType.CALL, self._seqid)
        args = QuaternionToMMI_args()
        args.quat = quat
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QuaternionToMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QuaternionToMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QuaternionToMMI failed: unknown result")

    def QuaternionFromMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        self.send_QuaternionFromMMI_L(quat, coordinateSystem)
        return self.recv_QuaternionFromMMI_L()

    def send_QuaternionFromMMI_L(self, quat, coordinateSystem):
        self._oprot.writeMessageBegin('QuaternionFromMMI_L', TMessageType.CALL, self._seqid)
        args = QuaternionFromMMI_L_args()
        args.quat = quat
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QuaternionFromMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QuaternionFromMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QuaternionFromMMI_L failed: unknown result")

    def QuaternionFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_QuaternionFromMMI(quat, firstAxis, secondAxis, thirdAxis)
        return self.recv_QuaternionFromMMI()

    def send_QuaternionFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('QuaternionFromMMI', TMessageType.CALL, self._seqid)
        args = QuaternionFromMMI_args()
        args.quat = quat
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QuaternionFromMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QuaternionFromMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QuaternionFromMMI failed: unknown result")

    def VectorToMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        self.send_VectorToMMI_L(quat, coordinateSystem)
        return self.recv_VectorToMMI_L()

    def send_VectorToMMI_L(self, quat, coordinateSystem):
        self._oprot.writeMessageBegin('VectorToMMI_L', TMessageType.CALL, self._seqid)
        args = VectorToMMI_L_args()
        args.quat = quat
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_VectorToMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = VectorToMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "VectorToMMI_L failed: unknown result")

    def VectorToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_VectorToMMI(quat, firstAxis, secondAxis, thirdAxis)
        return self.recv_VectorToMMI()

    def send_VectorToMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('VectorToMMI', TMessageType.CALL, self._seqid)
        args = VectorToMMI_args()
        args.quat = quat
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_VectorToMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = VectorToMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "VectorToMMI failed: unknown result")

    def VectorFromMMI_L(self, quat, coordinateSystem):
        """
        Parameters:
         - quat
         - coordinateSystem

        """
        self.send_VectorFromMMI_L(quat, coordinateSystem)
        return self.recv_VectorFromMMI_L()

    def send_VectorFromMMI_L(self, quat, coordinateSystem):
        self._oprot.writeMessageBegin('VectorFromMMI_L', TMessageType.CALL, self._seqid)
        args = VectorFromMMI_L_args()
        args.quat = quat
        args.coordinateSystem = coordinateSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_VectorFromMMI_L(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = VectorFromMMI_L_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "VectorFromMMI_L failed: unknown result")

    def VectorFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        """
        Parameters:
         - quat
         - firstAxis
         - secondAxis
         - thirdAxis

        """
        self.send_VectorFromMMI(quat, firstAxis, secondAxis, thirdAxis)
        return self.recv_VectorFromMMI()

    def send_VectorFromMMI(self, quat, firstAxis, secondAxis, thirdAxis):
        self._oprot.writeMessageBegin('VectorFromMMI', TMessageType.CALL, self._seqid)
        args = VectorFromMMI_args()
        args.quat = quat
        args.firstAxis = firstAxis
        args.secondAxis = secondAxis
        args.thirdAxis = thirdAxis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_VectorFromMMI(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = VectorFromMMI_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "VectorFromMMI failed: unknown result")


class Processor(MMIStandard.services.MMIServiceBase.Processor, Iface, TProcessor):
    def __init__(self, handler):
        MMIStandard.services.MMIServiceBase.Processor.__init__(self, handler)
        self._processMap["TransformToMMI_L"] = Processor.process_TransformToMMI_L
        self._processMap["TransformToMMI"] = Processor.process_TransformToMMI
        self._processMap["TransformFromMMI_L"] = Processor.process_TransformFromMMI_L
        self._processMap["TransformFromMMI"] = Processor.process_TransformFromMMI
        self._processMap["QuaternionToMMI_L"] = Processor.process_QuaternionToMMI_L
        self._processMap["QuaternionToMMI"] = Processor.process_QuaternionToMMI
        self._processMap["QuaternionFromMMI_L"] = Processor.process_QuaternionFromMMI_L
        self._processMap["QuaternionFromMMI"] = Processor.process_QuaternionFromMMI
        self._processMap["VectorToMMI_L"] = Processor.process_VectorToMMI_L
        self._processMap["VectorToMMI"] = Processor.process_VectorToMMI
        self._processMap["VectorFromMMI_L"] = Processor.process_VectorFromMMI_L
        self._processMap["VectorFromMMI"] = Processor.process_VectorFromMMI
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_TransformToMMI_L(self, seqid, iprot, oprot):
        args = TransformToMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = TransformToMMI_L_result()
        try:
            result.success = self._handler.TransformToMMI_L(args.transform, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("TransformToMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_TransformToMMI(self, seqid, iprot, oprot):
        args = TransformToMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = TransformToMMI_result()
        try:
            result.success = self._handler.TransformToMMI(args.transform, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("TransformToMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_TransformFromMMI_L(self, seqid, iprot, oprot):
        args = TransformFromMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = TransformFromMMI_L_result()
        try:
            result.success = self._handler.TransformFromMMI_L(args.transform, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("TransformFromMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_TransformFromMMI(self, seqid, iprot, oprot):
        args = TransformFromMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = TransformFromMMI_result()
        try:
            result.success = self._handler.TransformFromMMI(args.transform, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("TransformFromMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QuaternionToMMI_L(self, seqid, iprot, oprot):
        args = QuaternionToMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QuaternionToMMI_L_result()
        try:
            result.success = self._handler.QuaternionToMMI_L(args.quat, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QuaternionToMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QuaternionToMMI(self, seqid, iprot, oprot):
        args = QuaternionToMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QuaternionToMMI_result()
        try:
            result.success = self._handler.QuaternionToMMI(args.quat, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QuaternionToMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QuaternionFromMMI_L(self, seqid, iprot, oprot):
        args = QuaternionFromMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QuaternionFromMMI_L_result()
        try:
            result.success = self._handler.QuaternionFromMMI_L(args.quat, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QuaternionFromMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QuaternionFromMMI(self, seqid, iprot, oprot):
        args = QuaternionFromMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QuaternionFromMMI_result()
        try:
            result.success = self._handler.QuaternionFromMMI(args.quat, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QuaternionFromMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_VectorToMMI_L(self, seqid, iprot, oprot):
        args = VectorToMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = VectorToMMI_L_result()
        try:
            result.success = self._handler.VectorToMMI_L(args.quat, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("VectorToMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_VectorToMMI(self, seqid, iprot, oprot):
        args = VectorToMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = VectorToMMI_result()
        try:
            result.success = self._handler.VectorToMMI(args.quat, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("VectorToMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_VectorFromMMI_L(self, seqid, iprot, oprot):
        args = VectorFromMMI_L_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = VectorFromMMI_L_result()
        try:
            result.success = self._handler.VectorFromMMI_L(args.quat, args.coordinateSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("VectorFromMMI_L", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_VectorFromMMI(self, seqid, iprot, oprot):
        args = VectorFromMMI_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = VectorFromMMI_result()
        try:
            result.success = self._handler.VectorFromMMI(args.quat, args.firstAxis, args.secondAxis, args.thirdAxis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("VectorFromMMI", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class TransformToMMI_L_args(object):
    """
    Attributes:
     - transform
     - coordinateSystem

    """


    def __init__(self, transform=None, coordinateSystem=None,):
        self.transform = transform
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = MMIStandard.math.ttypes.MTransform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = iprot.readI32()
                        self.coordinateSystem.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformToMMI_L_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter330 in self.coordinateSystem:
                oprot.writeI32(iter330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformToMMI_L_args)
TransformToMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class TransformToMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MTransform()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformToMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformToMMI_L_result)
TransformToMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 0
)


class TransformToMMI_args(object):
    """
    Attributes:
     - transform
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, transform=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.transform = transform
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = MMIStandard.math.ttypes.MTransform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformToMMI_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformToMMI_args)
TransformToMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class TransformToMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MTransform()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformToMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformToMMI_result)
TransformToMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 0
)


class TransformFromMMI_L_args(object):
    """
    Attributes:
     - transform
     - coordinateSystem

    """


    def __init__(self, transform=None, coordinateSystem=None,):
        self.transform = transform
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = MMIStandard.math.ttypes.MTransform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype334, _size331) = iprot.readListBegin()
                    for _i335 in range(_size331):
                        _elem336 = iprot.readI32()
                        self.coordinateSystem.append(_elem336)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformFromMMI_L_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter337 in self.coordinateSystem:
                oprot.writeI32(iter337)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformFromMMI_L_args)
TransformFromMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class TransformFromMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MTransform()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformFromMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformFromMMI_L_result)
TransformFromMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 0
)


class TransformFromMMI_args(object):
    """
    Attributes:
     - transform
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, transform=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.transform = transform
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = MMIStandard.math.ttypes.MTransform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformFromMMI_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformFromMMI_args)
TransformFromMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class TransformFromMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MTransform()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformFromMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TransformFromMMI_result)
TransformFromMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 0
)


class QuaternionToMMI_L_args(object):
    """
    Attributes:
     - quat
     - coordinateSystem

    """


    def __init__(self, quat=None, coordinateSystem=None,):
        self.quat = quat
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MQuaternion()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype341, _size338) = iprot.readListBegin()
                    for _i342 in range(_size338):
                        _elem343 = iprot.readI32()
                        self.coordinateSystem.append(_elem343)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionToMMI_L_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter344 in self.coordinateSystem:
                oprot.writeI32(iter344)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionToMMI_L_args)
QuaternionToMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class QuaternionToMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MQuaternion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionToMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionToMMI_L_result)
QuaternionToMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 0
)


class QuaternionToMMI_args(object):
    """
    Attributes:
     - quat
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, quat=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.quat = quat
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MQuaternion()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionToMMI_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionToMMI_args)
QuaternionToMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class QuaternionToMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MQuaternion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionToMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionToMMI_result)
QuaternionToMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 0
)


class QuaternionFromMMI_L_args(object):
    """
    Attributes:
     - quat
     - coordinateSystem

    """


    def __init__(self, quat=None, coordinateSystem=None,):
        self.quat = quat
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MQuaternion()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readI32()
                        self.coordinateSystem.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionFromMMI_L_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter351 in self.coordinateSystem:
                oprot.writeI32(iter351)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionFromMMI_L_args)
QuaternionFromMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class QuaternionFromMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MQuaternion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionFromMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionFromMMI_L_result)
QuaternionFromMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 0
)


class QuaternionFromMMI_args(object):
    """
    Attributes:
     - quat
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, quat=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.quat = quat
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MQuaternion()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionFromMMI_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionFromMMI_args)
QuaternionFromMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class QuaternionFromMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MQuaternion()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuaternionFromMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QuaternionFromMMI_result)
QuaternionFromMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MQuaternion, None], None, ),  # 0
)


class VectorToMMI_L_args(object):
    """
    Attributes:
     - quat
     - coordinateSystem

    """


    def __init__(self, quat=None, coordinateSystem=None,):
        self.quat = quat
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MVector3()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype355, _size352) = iprot.readListBegin()
                    for _i356 in range(_size352):
                        _elem357 = iprot.readI32()
                        self.coordinateSystem.append(_elem357)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorToMMI_L_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter358 in self.coordinateSystem:
                oprot.writeI32(iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorToMMI_L_args)
VectorToMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class VectorToMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MVector3()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorToMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorToMMI_L_result)
VectorToMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 0
)


class VectorToMMI_args(object):
    """
    Attributes:
     - quat
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, quat=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.quat = quat
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MVector3()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorToMMI_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorToMMI_args)
VectorToMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class VectorToMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MVector3()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorToMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorToMMI_result)
VectorToMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 0
)


class VectorFromMMI_L_args(object):
    """
    Attributes:
     - quat
     - coordinateSystem

    """


    def __init__(self, quat=None, coordinateSystem=None,):
        self.quat = quat
        self.coordinateSystem = coordinateSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MVector3()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.coordinateSystem = []
                    (_etype362, _size359) = iprot.readListBegin()
                    for _i363 in range(_size359):
                        _elem364 = iprot.readI32()
                        self.coordinateSystem.append(_elem364)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorFromMMI_L_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinateSystem is not None:
            oprot.writeFieldBegin('coordinateSystem', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.coordinateSystem))
            for iter365 in self.coordinateSystem:
                oprot.writeI32(iter365)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorFromMMI_L_args)
VectorFromMMI_L_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 1
    (2, TType.LIST, 'coordinateSystem', (TType.I32, None, False), None, ),  # 2
)


class VectorFromMMI_L_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MVector3()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorFromMMI_L_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorFromMMI_L_result)
VectorFromMMI_L_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 0
)


class VectorFromMMI_args(object):
    """
    Attributes:
     - quat
     - firstAxis
     - secondAxis
     - thirdAxis

    """


    def __init__(self, quat=None, firstAxis=None, secondAxis=None, thirdAxis=None,):
        self.quat = quat
        self.firstAxis = firstAxis
        self.secondAxis = secondAxis
        self.thirdAxis = thirdAxis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.quat = MMIStandard.math.ttypes.MVector3()
                    self.quat.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.firstAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.secondAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.thirdAxis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorFromMMI_args')
        if self.quat is not None:
            oprot.writeFieldBegin('quat', TType.STRUCT, 1)
            self.quat.write(oprot)
            oprot.writeFieldEnd()
        if self.firstAxis is not None:
            oprot.writeFieldBegin('firstAxis', TType.I32, 2)
            oprot.writeI32(self.firstAxis)
            oprot.writeFieldEnd()
        if self.secondAxis is not None:
            oprot.writeFieldBegin('secondAxis', TType.I32, 3)
            oprot.writeI32(self.secondAxis)
            oprot.writeFieldEnd()
        if self.thirdAxis is not None:
            oprot.writeFieldBegin('thirdAxis', TType.I32, 4)
            oprot.writeI32(self.thirdAxis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorFromMMI_args)
VectorFromMMI_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'quat', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 1
    (2, TType.I32, 'firstAxis', None, None, ),  # 2
    (3, TType.I32, 'secondAxis', None, None, ),  # 3
    (4, TType.I32, 'thirdAxis', None, None, ),  # 4
)


class VectorFromMMI_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.math.ttypes.MVector3()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VectorFromMMI_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(VectorFromMMI_result)
VectorFromMMI_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs

